<?php
/**
 * Peanut Connect Activity Log
 *
 * Records significant events for audit and debugging purposes.
 * Stored securely in the same protected directory as error logs.
 *
 * @package Peanut_Connect
 * @since 2.2.0
 */

if (!defined('ABSPATH')) {
    exit;
}

class Peanut_Connect_Activity_Log {

    /**
     * Log file path
     */
    private static string $log_file;

    /**
     * Log directory path
     */
    private static string $log_dir;

    /**
     * Maximum log entries to keep
     */
    private const MAX_ENTRIES = 1000;

    /**
     * Activity types
     */
    public const TYPE_HEALTH_CHECK = 'health_check';
    public const TYPE_UPDATE_INSTALLED = 'update_installed';
    public const TYPE_UPDATE_FAILED = 'update_failed';
    public const TYPE_CONNECTION_ESTABLISHED = 'connection_established';
    public const TYPE_CONNECTION_LOST = 'connection_lost';
    public const TYPE_KEY_GENERATED = 'key_generated';
    public const TYPE_KEY_REGENERATED = 'key_regenerated';
    public const TYPE_PERMISSION_CHANGED = 'permission_changed';
    public const TYPE_SETTINGS_CHANGED = 'settings_changed';
    public const TYPE_RATE_LIMITED = 'rate_limited';
    public const TYPE_AUTH_FAILED = 'auth_failed';
    public const TYPE_DISCONNECT = 'disconnect';

    /**
     * Activity status
     */
    public const STATUS_SUCCESS = 'success';
    public const STATUS_WARNING = 'warning';
    public const STATUS_ERROR = 'error';
    public const STATUS_INFO = 'info';

    /**
     * Initialize activity logging
     */
    public static function init(): void {
        self::$log_dir = WP_CONTENT_DIR . '/peanut-logs';
        self::$log_file = self::$log_dir . '/activity-log.json';

        // Ensure log directory exists
        self::ensure_log_directory();
    }

    /**
     * Ensure log directory exists and is protected
     */
    private static function ensure_log_directory(): void {
        if (!file_exists(self::$log_dir)) {
            wp_mkdir_p(self::$log_dir);
        }

        // .htaccess protection (same as error log)
        $htaccess_file = self::$log_dir . '/.htaccess';
        if (!file_exists($htaccess_file)) {
            $htaccess_content = "# Protect log files from direct access\n";
            $htaccess_content .= "# Generated by Peanut Connect\n\n";
            $htaccess_content .= "<IfModule mod_authz_core.c>\n";
            $htaccess_content .= "    Require all denied\n";
            $htaccess_content .= "</IfModule>\n";
            $htaccess_content .= "<IfModule !mod_authz_core.c>\n";
            $htaccess_content .= "    Order deny,allow\n";
            $htaccess_content .= "    Deny from all\n";
            $htaccess_content .= "</IfModule>\n";

            @file_put_contents($htaccess_file, $htaccess_content);
        }
    }

    /**
     * Log an activity
     *
     * @param string $type    Activity type (use class constants)
     * @param string $status  Activity status (success, warning, error, info)
     * @param string $message Human-readable description
     * @param array  $meta    Additional metadata
     */
    public static function log(
        string $type,
        string $status,
        string $message,
        array $meta = []
    ): void {
        // Ensure initialized
        if (empty(self::$log_file)) {
            self::init();
        }

        $entry = [
            'id' => wp_generate_uuid4(),
            'type' => $type,
            'status' => $status,
            'message' => $message,
            'timestamp' => current_time('mysql'),
            'timestamp_gmt' => gmdate('Y-m-d H:i:s'),
            'user_id' => get_current_user_id(),
            'ip_address' => self::get_client_ip(),
        ];

        // Add metadata if provided
        if (!empty($meta)) {
            $entry['meta'] = $meta;
        }

        $entries = self::get_entries();
        array_unshift($entries, $entry);

        // Trim to max entries
        $entries = array_slice($entries, 0, self::MAX_ENTRIES);

        @file_put_contents(
            self::$log_file,
            json_encode($entries, JSON_PRETTY_PRINT),
            LOCK_EX
        );
    }

    /**
     * Get activity log entries
     *
     * @param int    $limit  Maximum entries to return (0 = all)
     * @param int    $offset Entries to skip
     * @param string $type   Filter by type
     * @param string $status Filter by status
     * @return array Activity entries
     */
    public static function get_entries(
        int $limit = 0,
        int $offset = 0,
        string $type = '',
        string $status = ''
    ): array {
        if (empty(self::$log_file)) {
            self::init();
        }

        if (!file_exists(self::$log_file)) {
            return [];
        }

        $content = @file_get_contents(self::$log_file);
        if (!$content) {
            return [];
        }

        $entries = json_decode($content, true);
        if (!is_array($entries)) {
            return [];
        }

        // Filter by type
        if (!empty($type)) {
            $entries = array_filter($entries, function($entry) use ($type) {
                return ($entry['type'] ?? '') === $type;
            });
        }

        // Filter by status
        if (!empty($status)) {
            $entries = array_filter($entries, function($entry) use ($status) {
                return ($entry['status'] ?? '') === $status;
            });
        }

        // Re-index after filtering
        $entries = array_values($entries);

        // Apply pagination
        if ($offset > 0) {
            $entries = array_slice($entries, $offset);
        }

        if ($limit > 0) {
            $entries = array_slice($entries, 0, $limit);
        }

        return $entries;
    }

    /**
     * Get entry counts by type
     *
     * @return array Counts keyed by type
     */
    public static function get_counts_by_type(): array {
        $entries = self::get_entries();
        $counts = [];

        foreach ($entries as $entry) {
            $type = $entry['type'] ?? 'unknown';
            $counts[$type] = ($counts[$type] ?? 0) + 1;
        }

        return $counts;
    }

    /**
     * Get entry counts for last 24 hours
     *
     * @return array Counts by status
     */
    public static function get_recent_counts(): array {
        $entries = self::get_entries();
        $cutoff = strtotime('-24 hours');

        $counts = [
            'success' => 0,
            'warning' => 0,
            'error' => 0,
            'info' => 0,
            'total' => 0,
        ];

        foreach ($entries as $entry) {
            $timestamp = strtotime($entry['timestamp'] ?? '');
            if ($timestamp >= $cutoff) {
                $status = $entry['status'] ?? 'info';
                if (isset($counts[$status])) {
                    $counts[$status]++;
                }
                $counts['total']++;
            }
        }

        return $counts;
    }

    /**
     * Clear activity log
     *
     * @return bool True if successful
     */
    public static function clear(): bool {
        if (empty(self::$log_file)) {
            self::init();
        }

        if (file_exists(self::$log_file)) {
            // Log the clear action before clearing
            self::log(
                self::TYPE_SETTINGS_CHANGED,
                self::STATUS_INFO,
                'Activity log cleared by administrator'
            );

            // Now clear (but keep the clear log entry)
            $entries = self::get_entries(1);
            return (bool) @file_put_contents(
                self::$log_file,
                json_encode($entries, JSON_PRETTY_PRINT),
                LOCK_EX
            );
        }

        return true;
    }

    /**
     * Export log as CSV
     *
     * @return string CSV content
     */
    public static function export_csv(): string {
        $entries = self::get_entries();

        $csv = "ID,Timestamp,Type,Status,Message,User ID,IP Address\n";

        foreach ($entries as $entry) {
            $csv .= sprintf(
                '"%s","%s","%s","%s","%s","%s","%s"' . "\n",
                $entry['id'] ?? '',
                $entry['timestamp'] ?? '',
                $entry['type'] ?? '',
                $entry['status'] ?? '',
                str_replace('"', '""', $entry['message'] ?? ''),
                $entry['user_id'] ?? '',
                $entry['ip_address'] ?? ''
            );
        }

        return $csv;
    }

    /**
     * Get client IP address
     *
     * @return string|null Client IP
     */
    private static function get_client_ip(): ?string {
        $headers = [
            'HTTP_CF_CONNECTING_IP',
            'HTTP_X_FORWARDED_FOR',
            'HTTP_X_REAL_IP',
            'REMOTE_ADDR',
        ];

        foreach ($headers as $header) {
            if (!empty($_SERVER[$header])) {
                $ip = $_SERVER[$header];
                if (strpos($ip, ',') !== false) {
                    $ips = explode(',', $ip);
                    $ip = trim($ips[0]);
                }
                if (filter_var($ip, FILTER_VALIDATE_IP)) {
                    return $ip;
                }
            }
        }

        return null;
    }

    // ==================
    // Helper Methods
    // ==================

    /**
     * Log a health check request
     */
    public static function log_health_check(string $manager_url = ''): void {
        self::log(
            self::TYPE_HEALTH_CHECK,
            self::STATUS_INFO,
            'Health check performed by manager',
            ['manager_url' => $manager_url]
        );
    }

    /**
     * Log an update installation
     */
    public static function log_update_installed(
        string $type,
        string $slug,
        string $old_version,
        string $new_version
    ): void {
        self::log(
            self::TYPE_UPDATE_INSTALLED,
            self::STATUS_SUCCESS,
            sprintf('%s "%s" updated from %s to %s', ucfirst($type), $slug, $old_version, $new_version),
            [
                'type' => $type,
                'slug' => $slug,
                'old_version' => $old_version,
                'new_version' => $new_version,
            ]
        );
    }

    /**
     * Log a failed update
     */
    public static function log_update_failed(
        string $type,
        string $slug,
        string $error
    ): void {
        self::log(
            self::TYPE_UPDATE_FAILED,
            self::STATUS_ERROR,
            sprintf('Failed to update %s "%s": %s', $type, $slug, $error),
            [
                'type' => $type,
                'slug' => $slug,
                'error' => $error,
            ]
        );
    }

    /**
     * Log site key generation
     */
    public static function log_key_generated(): void {
        self::log(
            self::TYPE_KEY_GENERATED,
            self::STATUS_SUCCESS,
            'Site key generated'
        );
    }

    /**
     * Log site key regeneration
     */
    public static function log_key_regenerated(): void {
        self::log(
            self::TYPE_KEY_REGENERATED,
            self::STATUS_WARNING,
            'Site key regenerated - previous connections invalidated'
        );
    }

    /**
     * Log permission change
     */
    public static function log_permission_changed(string $permission, bool $enabled): void {
        self::log(
            self::TYPE_PERMISSION_CHANGED,
            self::STATUS_INFO,
            sprintf('Permission "%s" %s', $permission, $enabled ? 'enabled' : 'disabled'),
            [
                'permission' => $permission,
                'enabled' => $enabled,
            ]
        );
    }

    /**
     * Log authentication failure
     */
    public static function log_auth_failed(string $reason): void {
        self::log(
            self::TYPE_AUTH_FAILED,
            self::STATUS_ERROR,
            sprintf('Authentication failed: %s', $reason),
            ['reason' => $reason]
        );
    }

    /**
     * Log rate limiting
     */
    public static function log_rate_limited(string $endpoint): void {
        self::log(
            self::TYPE_RATE_LIMITED,
            self::STATUS_WARNING,
            sprintf('Rate limit exceeded for endpoint: %s', $endpoint),
            ['endpoint' => $endpoint]
        );
    }

    /**
     * Log disconnection
     */
    public static function log_disconnect(string $initiated_by = 'admin'): void {
        self::log(
            self::TYPE_DISCONNECT,
            self::STATUS_INFO,
            sprintf('Disconnected from manager (initiated by %s)', $initiated_by),
            ['initiated_by' => $initiated_by]
        );
    }
}
